function res = upredict(rex,rexx)
% PURPOSE: Forecasting with univariate ARX/BARX models
% ------------------------------------------------------------
% SYNTAX: res = upredict(rex,rexx);
% ------------------------------------------------------------
% OUTPUT: a structure ...
%         zf : npred x 1   Forecasts: point estimate
%         sf : npred x 1   Forecasts: std. deviation
% ------------------------------------------------------------
% INPUT: rex --> a structure ...
%        X    : nxm matrix of exogenous series, columnwise
%        z    : nx1 vector of original series, columnwise
%        opC  : 1x1 indicator to include (1) an intercept or not (0)
%        p    : 1x1 order of the model
%        rexx --> a structure generated by arx or barx
%        npred: 1x1 number of forecasts
% ------------------------------------------------------------
% LIBRARY: impz
% ------------------------------------------------------------
% SEE ALSO: arx, barx

% ------------------------------------------------------------
% written by:
%  Enrique M. Quilis

% September 2007
% Version 1.1

% ------------------------------------------------------------
% Transfer from res structure

z     = rex.z;
n     = rexx.parm(1);
nobs  = rexx.parm(2);
k     = rexx.parm(3); 
if (k ~= 1)
    error('*** ONLY UNIVARIATE MODELING, PLEASE ***');
end
p     = rexx.parm(4);
mu    = rexx.mu;
b     = rexx.b;
phi   = rexx.phi;
m     = length(b);
opC   = length(mu);

% ==================================================================================
%  TRANSITION EQUATION MATRICES: Y(t) = E X(t) + H Y(t-1) + V(t) ==> E, H
% ==================================================================================

% Exogenous inputs matrix E : p x (m+1)

E = [mu b'
    zeros(p-1,m+opC) ];
 
% Dynamic matrix H : p x p

H =[phi'
    eye(p-1) zeros(p-1,1) ];
 
% ==================================================================================
%  MEASUREMENT EQUATION MATRIX  z(t) = G Y(t) ==> G : 1 x p
% ==================================================================================

G = zeros(1,p);
G(1,1) = 1;

% ==================================================================================
%  PREPARING THE DYNAMIC RECURRENCE (intercept + exogenous variables)
% ==================================================================================

Xf = [ones(rex.npred,rex.opC) rex.Xf];

% The following operation is needed to ensure conformity in the 
% recurrence of the transtion equation, that begins at h=2, not h=1

aux = size(Xf);
Xf = [ NaN*ones(1,aux(1,2))
       Xf ];      
clear aux;
       
Xf = Xf';

% ==================================================================================
%  PREPARING THE DYNAMIC RECURRENCE (state vector)
% ==================================================================================

% Set of common regressors up to lag p: z(t-1)..z(t-p).
% Automatically includes a variable (=1) for the intercept 
% so it should be deleted. The last lagged also shuould be exluced.
% The contemporaneous observations should be included via z(t)

ze = lag(z,p);    % Lag vector z
ze = ze(:,2:end-1);  % Exclude first and last col
ze = [z(p+1:end,:) ze];  % Include contemporaneous Z

% ------------------------------------------------------------
% Recurrence to generate npred forecasts using transition equation

zef(1,:) = ze(n-p,:);   % Initial conditions for recurrence
zef=zef';

for h=2:rex.npred+1
   zef(:,h) =  E * Xf(:,h) + H * zef(:,h-1);  % Rows are variables, cols are obs.
end

zef=zef(:,2:end);  %First col. is initial condition and should be deleted

% ------------------------------------------------------------
% Static selection of forecasts by means of the measurement equation

zf = G * zef; % Rows are variables, cols are obs.

% ==================================================================================
%  FORECAST ERROR COVARIANCE
% ==================================================================================

% Initial condition
sf(1) = rexx.sigma;

ar = [1 -rexx.phi'];
ma = [1];

[f,aux] = impz(ma,ar,rex.npred+1);

for t=2:rex.npred
   sf(t) = sf(t-1) + rexx.sigma * (f(t))^2;
end

sf = sqrt(sf);

% ------------------------------------------------------------
% Loading the structure

res.zf  =  zf';      % Forecasts: point estimate
res.sf =   sf';	   % Forecasts: std. deviation

